<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Медиа-запросы</title>
    <link rel="stylesheet" href="./css/style_lesson14.css">
</head>
<body class="container">
    <h1>Медиа-Запросы</h1>
    <p>Медиа-запросы - это то, что делает возможным создание современных адаптивных веб-страниц, которые одинаково хорошо выглядят на любом экране, будь то десктоп или смартфон. Всё сводится к применению того или иного CSS-правила к элементу, в зависимости от размера экрана пользователя (вьюпорта браузера), возможностей устройства или пользовательских предпочтений.</p>
    <img src="./images/media-queries-intro.png" alt="">
    <p>Алгоритм применения стилей следующий:</p>
    <ul>
        <li>
            Разработчик описывает набор медиа-запросов и CSS-правил внутри них.
        </li>
        <li>
            Браузер отслеживает изменение размера вьюпорта.
        </li>
        <li>>
            Браузер применяет CSS-правила из медиа-запросов подходящих под текущий размер вьюпорта.
        </li>
    </ul>
    <div class="advice">
        <p>
            Человеческим языком, медиа-запросы это инстуркция по типу: «когда страницу открыли на десктопе, я хочу, чтобы текст веб-страницы был красным, а при открытии на телефоне, цвет текста должен быть зелёным».
        </p>
    </div>
    <h2>Синтаксис</h2>
    <img src="./images/syntax.JPG" alt="">
    <p>
        Медиа-запрос это просто специальная CSS-конструкция, которая начинается с директивы @media, за которой может следовать тип устройства (media-type) и медиа-функции (media feature) - выражения проверяющие характеристики устройства (например ширину вьюпорта). Медиа-функция это логическое выражение, которое возвращает истину (верно) или ложь (не верно).
    </p>
    <p>
        Например, если необходимо сделать фон <body> оранжевым при ширине вьюпорта 900px и шире, необходимо записать следующий медиа-запрос.
    </p>
    <img src="./images/syntax1.JPG" alt="">
    <p>
        Человеческим языком это можно прочитать как: «если страница отображается на экране, и ширина этого экрана не менее 900 пикселей, необходимо применить указанное CSS-правило».
    </p>
    <p>
        Цвет фона <body> будет изменяться в зависимости от ширины вьюпорта, укзанной в медиа-запросах.
    </p>
    <img src="./images/syntax2.JPG" alt="">
    <p>
        Условие проверки может быть настолько сложным или простым, насколько этого требует ситуация. В большинстве случаев достаточно указать медиа-тип устройства (чаще всего screen), и проверить только ширину вьюпорта.
    </p>
    <img src="./images/syntax3.JPG" alt="">
    <div class="attention">
        <p>
            Если тип устройства не указан, будет использовано значение по умолчанию - all, то есть любой.
        </p>
    </div>
    <div class="webinar">
        <p>
            <b>В SASS</b> медиазапросы можно вкладывать прямо в селектор.
        </p>
        <img src="./images/media-css.JPG" alt="">
    </div>
    <h2>Медиа-типы</h2>
    <p>
        Медиа-тип (тип носителя) используется для описания типа устройства, на котором была открыта веб-страница в браузере. Раньше было очень много типов, к счастью сегодня их осталось всего четыре.
    </p>
    <ul>
        <li>
            all - как упоминалось ранее, если не указать тип носителя, по умолчанию будет использовано это значение, которое означает любое устройство.
        </li>
        <li>
            screen - описывает устройства с физическим экраном: смартфоны, планшеты, мониторы, телевизоры и т. д.
        </li>
        <li>
            print - в основном используется для указания стилей при распечатке веб-страницы.
        </li>
        <li>
            speech - для использования с синтезаторами речи, такими как скринридеры. Пока что ни один браузер не поддерживает этот тип.
        </li>
    </ul>

    <h2>Медиа-функции</h2>
    <p>
        Разберём две самые часто используемые медиа-функции для определения ширины вьюпорта.
    </p>
    <ul>
        <li>
            min-width: значение - когда необходимо проверить что ширина вьюпорта не меньше (больше) чем указанное значение.
        </li>
        <li>
            max-width: значение - когда необходимо проверить что ширина вьюпорта не больше (меньше) чем указанное значение.
        </li>
    </ul>
    <p>
        То есть указывается максимальная и минимальная допустимые ширины вьюпорта, при которых применяются правила из медиа-запросов.
    </p>
    <img src="./images/syntax4.JPG" alt="">
    <p>
        Если представить ширину вьюпорта как прямую от 0 до бесконечности, то мы описываем промежуток, на котором необходимо применить какие-то стили.
    </p>
    <img src="./images/min-max-queries.png" alt="">
    <p>
        При изменении ширины вьюпорта в примере, до 600px фон <body> будет желтого цвета, а после 900px - зелёного. В промежутке от 601px до 899px - цвет белый, значение указанное по умолчанию, потому что ни один медиа-запрос не подойдёт.
    </p>
    <img src="./images/syntax5.JPG" alt="">
    <p>
        А как описать промежуток, например от 600px до 900px? Необходимо использовать логические операторы для составных медиа-функций.
    </p>

    <h2>Логические операторы</h2>
    <p>
        Медиа-тип и медиа-функции могут быть разделены необязательными логическими операторами not, and и only - значение по умолчанию. Полный синтаксис медиа-запроса выглядит следующим образом.
    </p>
    <img src="./images/logic.JPG" alt="">
    <h3>Оператор <b>and</b></h3>
    <p>
        Оператор and (буквально «И») можно использовать не только между типом носителя и медиа-условием, но и для связывания нескольких медиа-функций с проверками значений.
    </p>
    <img src="./images/logic1.JPG" alt="">
    <p>
        Медиа-запрос из примера сработает только если веб-страница открыта на экране, а ширина вьюпорта в диапазоне от 400px до 800px.
    </p>
    <img src="./images/query-segment.png" alt="">

    <h3>Оператор <b>not</b></h3>
    <p>
        Оператор not (буквально «НЕ») позволяет сделать отрицание, то есть отменить медиа-запрос. Ключевое слово not добавляется в начало медиазапроса и применяется ко всему запросу целиком. Используется очень не часто.
    </p>
    <p>
        Например, запишем условие при котором стили должны примениться везде кроме печати.
    </p>
    <img src="./images/not.JPG" alt="">
    <p>
        При использовании оператора not обязательно должен быть указан тип носителя, потому что по умолчанию для него будет установлено значение all и выражение not all будет читаться буквально как «не все», и медиа-запрос не выполнился никогда.
    </p>
    <img src="./images/not1.JPG" alt="">

    <h3>Оператор <b>,</b></h3>
    <p>
        Оператор , (буквально «ИЛИ») позволяет указать набор выражений, при выполнении хотябы одного из которых, необходимо применить стили.
    </p>
    <p>
        Например, необходимо применить стили промежутке до 600px, или после 900px.
    </p>
    <img src="./images/or.JPG" alt="">
    <img src="./images/min-max-queries1.png" alt="">
    <p>
        То есть это просто перечисление набора медиа-запросов при которых должны примениться стили. Это можно записать как два разных медиа-запроса. Но тогда код стилей body будет дублироваться.
    </p>
    <img src="./images/or1.JPG" alt="">
    <div class="advice">
        <p>
            В будущих редакциях CSS, оператор , будет заменён на оператор or, что переводится как или.
        </p>
    </div>
    
    <h2>Переопределение стилей</h2>
    <p>
        Ничто не мешает браузеру применить более одного медиа-запроса одновременно, если они подходят по условию. Медиа-запросы не добавляют специфичности к селекторам, которые они содержат, но порядок правил по-прежнему имеет значение. Это значит что правила находящиеся в медиа-запросах участвуют в стандартном каскадировании при составлении финальных стилей элемента.
    </p>
    <img src="./images/change.JPG" alt="">
    <p>
        Например, в предыдущих примерах, переопределялся цвет фона элемента body, это можо увидеть в инструментах разработчика.
    </p>
    <img src="./images/overriding-styles.png" alt="">
    <p>
        При этом переопределяются только одинаковые свойства, а не всё правило целиком. Благодаря этому можно делать слоёный пирог из стилей, не дублируя предыдущие, которые подходят и для текущего медиа-запроса.
    </p>
    <img src="./images/change2.JPG" alt="">

    <h1>Метатег VIEWPORT</h1>
    <p>
        Окно просмотра (вьюпорт, viewport) - это видимая, прямоугольная область веб-страницы, не включающая адресную строку, панель закладок и другие служебные элементы браузера.
    </p>
    <img src="./images/viewport.png" alt="">
    <p>
        Мобильные браузеры отображают веб-страницу во вьюпорте, который шире чем физический экран устройства. По умолчанию, ширина вьюпорта в мобильных браузерах зависит от производителя устройства, не совпадает с размером экрана устройства, и чаще всего равна 980px. Это значит, что мобильный браузер считает это величиной, относительно которой он должен применять медиа-запросы.
    </p>
    <p>
        То есть медиа-запросы ориентированные на мобильные устройства просто не применятся, или будут переопределены в мобильном браузере. Например, при открытии веб-страницы на экране шириной 400px, применится медиа-запрос с min-width: 768px переопределив мобильные стили, и мы увидим вариант страницы для планшетов, хотя открыли на телефоне.
    </p>
    <p>
        Страницы, адаптированные для просмотра на разных устройствах, должны содержать в разделе <head> мета-тег viewport. Он сообщает браузеру, каким образом нужно контролировать размеры и масштаб вьюпорта.
    </p>
    <img src="./images/viewport1.JPG" alt="">
    <ul>
        <li>
            width=device-width - устанавливает ширину вьюпорта (width) равной физической ширине экрана устройства (device-width).
        </li>
        <li>
            initial-scale=1.0 - устанавливает соотношение (масштаб) 1:1 между CSS-пикселями и аппаратными пикселями устройства.
        </li>
    </ul>
    <img src="./images/mobile-viewport.jpg" alt="">

    <h2>Дополнительные материалы</h2>
    <a href="https://www.quirksmode.org/mobile/viewports2.html">
        A tale of two viewports (англ)
    </a>

    <h1>Инструменты разработчика</h1>
    <img src="./images/devtools.png" alt="">
    <p>
        Для того чтобы перейти в отзывчивый режим в браузере Chrome, необходимо открыть инструменты разработчика и нажать на иконку 1. Появятся дополнительные инструменты для работы с отзывчивой вёрсткой. Чтобы выйти из этого режима, необходимо нажать на иконку 1 ещё раз.
    </p>
    <p>
        Для того чтобы изменить ширину вьюпорта простым растягиванием, используется элемент 2. Эффект такой, как будто растягивается или сжиматся окно браузера, тем самым изменяя ширину вьюпорта.
    </p>
    <p>
        В верхней части инрументов находится набор дополнительных элементов управления.
    </p>
    <ul>
        <li>
            3 - выбор устройства с точными размерами, например iPhone, iPad, Pixel и т. д., либо значение по умолчанию - Reponsive, отзывчивый режим с произвольной шириной вьюпорта контролируемой разработчиком.
        </li>
        <li>
            4 - текущие размеры ширины и высоты вьюпорта. Можно вводить значения вручную.
        </li>
        <li>
            5 - изменение масштаба, на случай когда работа идёт с большими величинами и нужно посмотреть всю вёрстку целиком.
        </li>
        <li>
            6 - возможность имитировать поворот устройства в портретный либо ландшафтный режим.
        </li>
    </ul>
    <p>
        Немного ниже набора дополнительных элементов управления, находится панель быстрого изменения ширины вьюпорта по стандартным точкам перелома.
    </p>
    <div class="attention">
        <b>ВНИМАНИЕ</b>
        <p>
            Точка перелома (breakpoint) - это размер вьюпорта, при котором вся вёрстка или её отдельные части изменяют свои стили, то есть меняется дизайн.
        </p>
    </div>

    <h1>Типы вёрстки</h1>
    <img src="./images/responsive-intro.jpg" alt="">
    <p>
        Изначально веб-страницы были с фиксированной вёрсткой. Если контейнер был в ширину 800 пикселей - он так и оставался 800 пикселей, на каком экране его ни открывай, большом или крохотном. В современном мире разнообразия мобильных устройств, такой подход устарел.
    </p>
    <p>
        В современном вебе используются новые подходы при создании веб-сайтов. Они сочетают в себе элементы «резиновой» вёрстки и новые, современные приёмы, такие как адаптивность (adaptive) и отзывчивость (responsive). Техники «адаптивной» и «отзывчивой» вёрстки отличаются тем, как задаётся ширина контейнера и вложенных в него элементов.
    </p>
    <img src="./images/responsive-vs-adaptive.gif" alt="">
    <p>
        <b> Отзывчивая (responsive) веб-страница </b> - имеет несколько вариантов отображения, переходы между ними плавные, элементы и контейнер тянутся как резиновые. При изменении размера вьюпорта - блоки плавно ужимаются или растягиваются, а когда наступает точка перелома (breakpoint) - меняют своё расположение так, чтобы оптимально занять всё свободное пространство по горизонтали.
    </p>
    <p>
        <b>Адаптивная (adaptive) веб-страница</b> - имеет несколько вариантов отображения, и в отличии от отзывчивой страницы - буквально. Дизайн изменяется рывками в жёстко заданных точках перелома, и не тянется между ними.
    </p>
    <div class="advice">
        <b>ВНИМАНИЕ</b>
        <p>
            При составлении медиа-запросов нужно ориентироваться на точки перелома дизайна, т. е. такие значения ширины вьюпорта, в которых дизайн существенно меняется. Определить их можно по макету нарисованному дизайнером.
        </p>
    </div>
    <p>
        Перейдите по <a href="https://codepen.io/goit-academy/details/ZEQBaEy">ссылке</a>  в полную версию примера и изменяйте ширину окна браузера, так будет видна разница между отзывчивым и адаптивным контейнерами. Цвет контейнеров меняется в каждой из произвольно выбранных точек перелома 600 и 900 пикселей.
    </p>
    <ul>
        <li>
            Обоим контейнерам задаётся свойство min-width - ширина вьюпорта, ниже которой дизайн не поддерживается. У пользователя с более узким экраном появится горизонтальная полоса прокрутки.
        </li>
        <li>
            Отзывчивому контейнеру задаётся свойство max-width в базовых стилях, чтобы он тянулся, но максимально был не шире указанного значения.
        </li>
        <li>
            Адаптивному контейнеру задаётся начальное значение ширины, после чего, оно переопределяется в каждой точке перелома.
        </li>
    </ul>
    <p>
        Какой подход использовать? Всё зависит от дизайна, типа веб-сайта и финансовых возможностей заказчика. Для большинства веб-сайтов малого и среднего бизнеса достаточно адаптивной версии. Отзывчивая вёрстка дороже, так как делать её дольше, но она незаменима в интерфейсах современных веб-приложений. Иногда бизнес-задачи лучше выполнит отдельная мобильная версия или вообще нативное приложение вместо веб-сайта.
    </p>

    <h1>Стратегия Mobile-First</h1>
    <p>
        Исторически сложилось так, что дизайнеры начинали разработку дизайна сайта для большого экрана, то есть первый и «главный» дизайн делался для рабочего стола компьютера, так как предполагает большую функциональность.
    </p>
    <p>
        Проблема такого подхода в том, что приоритет отдаётся пользователям компьютеров и ноутбуков, хотя сейчас, по статистике, доминирует мобильный трафик. Многие элементы дизайна и функционала, которые отлично смотрятся и работают на рабочем столе компьютера, просто невозможно успешно перенести на мобильный экран.
    </p>
    <p>
        Стратегия Mobile-first идёт от обратного - сначала делается мобильная версия, после чего планшетная и десктопная. Это делает актуальную информацию легко доступной и позволяет скрыть или изменить элементы на любом экране.
    </p>
    <img src="./images/mobile-ferst.JPG" alt="">
    <p>
        Веб-сайт должен быть хорошо оптимизирован для поисковых систем (SEO) и отвечать всем требованиям UX (user experience), что бы прибывание пользователя на сайте было максимально удобным и понятным через его мобильное устройство. Поэтому одни из самых важных требований в Mobile-first разработке это:
    </p>
    <ul>
        <li>
            Показать самое важное содержание в первую очередь.
        </li>
        <li>
            Вебсайт должен быть легковесным и оптимизированным, т. к. скорость подключения мобильной сети может быть слабой в зависимости от местонахождения пользователя.
        </li>
        <li>
            Веб-сайт не должен загружать больше ресурсов, чем требуется пользователю для получения нужной информации.
        </li>
        <li>
            Дополнительная информация должна грузиться только по требованию пользователя.
        </li>
    </ul>
    <p>
        При разработке веб-сайта у такого подхода есть большие преимущества.
    </p>
    <ul>
        <li>
            <b> Один веб-сайт </b> - для всех устройств только один проект. Сокращает необходимое количество разработчиков.
        </li>
        <li>
            <b>Удобство интерфейса</b> - пользователи получат важное содержание страницы в первую очередь.
        </li>
        <li>
            <b>Скорость загрузки</b> - страница будет грузиться быстрее на мобильных устройствах из-за того, что количество загружаемых и отображаемых ресурсов будет меньше.
        </li>
        <li>
            <b>Рейтинг в поиске</b> - например Google не только отдаёт приоритет сайтам, оптимизированным для мобильных устройств, но и учитывает время открытия страниц.
        </li>
    </ul>
    <h2>Mobile First CSS</h2>
    <p>
        Технически реализация Mobile-first довольно проста - стили для мобильных устройств это базовые стили вне медиа-запросов, после чего, для каждой точки перелома добавялется медиа-запрос в котором переопределяются необходимые базовые стили, стили из предыдущего промежутка или добавляются новые. Поэтому в медиа-запросах, в основном, используется медиа-функция min-width.
    </p>
    <img src="./images/mfcss.JPG" alt="">
    <div class="advice">
        <b>НА ЗАМЕТКУ</b>
        <p>
            При таком подходе создаётся легковесная версия стилей для мобильных устройств, а все стили для более широких экранов закрываются внутри соответствующих медиа-запросов. При этом HTML-разметка не меняется.
        </p>
    </div>
    <p>
        Плюс такого подхода заключается в том, что для мобильных стилей практически никогда не нужно задавать позиционирование, например при помощи Flexbox, потому что весь контент идёт в одну колонку друг за другом - дефолтное поведение блочных элементов в стандартном потоке документа. Это значит, что в медиа-запросах для более широких экранов, не придётся переопределять позиционирование - большой плюс.
    </p>
    <p>
        На илюстрации ниже показана структура медиа-запросов и стилей для простой страницы с 2-мя точками перелома 768px и 1024px. CSS-правила внутри медиа-запросов просто добавляют новые стили или переопределяют предыдущие.
    </p>
    <img src="./images/mobile-first-css.png" alt="">
    <p>
        Перейдите в полную версию редактора примера по <a href="https://codepen.io/goit-academy/pen/MWKJWem">ссылке</a>  и изменяйте ширину окна браузера. Заметьте, изначально даже нет @media, так как стили пишутся для узкого экрана как база. Уже потом, при написании стилей для более широких экранов, мы добавляем медиа-запросы.
    </p>
    <p>
        При таком подходе имеем только плюсы:
    </p>
    <ul>
        <li>
            Базовый CSS-код более чистый, так как нам помогает поток документа и блочная модель при позиционировании элементов интерфейса.
        </li>
        <li>
            Наследование стилей от узких к широким экранам.
        </li>
        <li>
            Минимальное переопределение стилей позиционирования, следующее из первого пункта.
        </li>
    </ul>

    <h2>Медиа-функция max-width</h2>
    <p>
        Для большинства ситуаций достаточно использовать min-width и добавить либо переопределить стили. Тем не менее, бывают ситуации когда использование медиа-функции max-width делает код чище и читабельнее.
    </p>
    <p>
        Представим такую ситуацию - в последнем примере элементам необходимо добавить нижний отступ только на мобильном устройстве, то есть до 767px (с 768 начинаются стили планшета). А для планшетного промежутка, от 768px до 1023px, необходимо чтобы у элементов появлялась рамка.
    </p>
    <p>
        Использование только min-width приведёт к тому, что в стилях медиа-запроса c min-width: 768px придётся обнулить нижний отступ элементов. А в стилях медиа-запроса с min-width: 1024px будем обнулять стили рамки. Не самое лучшее решение,
    </p>
    <p>
        В таких ситуациях хорошей практикой будет закрыть специфичные стили в определёных промежутках, и поможет нам в этом медиа-функция max-width.
    </p>
    <img src="./images/mobile-first-composition.png" alt="">
    <p>
        Перейдите в полную версию редактора примера по <a href="https://codepen.io/goit-academy/pen/MWKJWem">ссылке</a>  и изменяйте ширину окна браузера.
    </p>

    <div class="webinar">
        <h1>Вебинар с Репетой</h1>
        <p>
            Чтобы сделать контейнеры отзывчивыми до определённого момента,
            т.е. чтобы до определённого момента расширения viewport они тянулись,
            а по достижении этой ширины зафиксировались, нужно прописать медиа-запрос
            @media screen and (min-width:480px) { width: 480px }. Что означает, что при достижении ширины вьюпорта 480рх
            зафиксируй контейнер на такой ширине. <br>
            Медиа-запрос прописывается внутри селектора в SASS.
            Таким образом страница будет сохранять пропорции до момента достижения следующей точки перелома - например до ширины планшета.

        </p>
        <p>
            Для того чтобы прописать переход на другой параметр, нужно прописать например
            @media screen (min-width: 768px) { width:768px; }, что означает что при достижении
            ширины экрана в 768рх и выше, зафиксируй контейнер на ширине 768рх. 
        </p>
        <div class="attention">
            <b>ЗАПОМНИТЬ</b>
            <p>
                Формула для calc для расчета ширины элемента для flex контейнера:
            </p>
            <img src="./images/calc.JPG" alt="">

        </div>

        <div class="advice">
            <b>СОВЕТ ДЛЯ ДОМАШКИ</b>
            <p>
                Если в своё макете для десктопа удалить все флексы и возможно марджины, теоретически должна получиться вёрстка для мобильной версии. 
            </p>
        </div>

        <p>
            <b>Скрывание вторичного контекта</b>
            <br>
            Бывает, что некоторые секции десктопной версии не нужны на мобильной.
            <br> Тогда в свойствах секции, которую нужно скрыть до определённого момента надо прописать 
            @media screen and (max-width: 767px) { display: none; }. <br>
            Это означает что у этой секции от 0 до ширины в 767рх display: none;. 
        </p>

        <p>
            <b>Первым делом для того чтобы страница масштабировалась</b> надо подключить мета тег 
                <br> meta name="viewport" content="width=device-width initial-scale=1.0"
                Сейчас он прописывается автоматически. 
            
        </p>
        <div class="advice">
            В devtools есть очень прикольная штука в режиме адаптивной вёрстки - имитация плохого интернета и того, что покажется при оффлайне. 
            <img src="./images/devtools.JPG" alt="">
        </div>

        <h3>Скролл для модалки</h3>
        <p>
            Надо в backdrop добавить свойство overflow-y: hidden;
        </p>
        <h3>Запрет скролла для страницы при открытой модалке</h3>
        <p>
            Это делается с помощью JS. <br>
            Суть в том, чтобы на body задать свойство overflow: hidden; при условии открытой модалки. 
            Если просто добавить на body это свойство, то оно обрежет body по границам вьюпорта и не будет прокручиваться вообще. 
        </p>
        









    </div>


    





</body>