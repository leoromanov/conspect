<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Препроцессоры</title>
    <link rel="stylesheet" href="./css/style_lesson14.css">
</head>
<body class="container">
    <h1>Препроцессоры</h1>
    <img src="./images/preprocessors.png" alt="">
    <p>
        Современный процесс разработки сильно отличается от того, каким он был на заре веб-индустрии. Кроме свободного владения всеми базовыми технологиями (HTML, CSS и JavaScript), необходимо уметь использовать целую мириаду вспомогательных инструментов.
    </p>
    <p>
        Один из таких инструментов это CSS-препроцессор - надстройка расширяющая CSS-синтаксис, облегчающая написание, поддержку и рефакторинг кода. Препроцессоры позволяют использовать функции, которые еще не существуют в CSS, такие как переменные (уже сущестуют), вложения, миксины, наследование и другие вкусности, которые ускоряют и упрощают написание CSS.
    </p>
    <p>
        Самые популярные препроцессоры это: SASS, LESS и Stylus. Все они похожи и решают одну задачу, поэтому достаточно выбрать и использовать один. Самый популярный препроцессор - SASS и его синтаксис SCSS.
    </p>
    ПРЕИМУЩЕСТВА
    <ul>
        <li>
            Совместимость - синтаксис препроцессора полностью совместим с уже существующими CSS-правилами. Готовый CSS-код можно вставить в SASS-файл, но не наоборот.
        </li>
        <li>
            Богатая функциональность - большое количество вспомогательных конструкций языка, для упрощения основных задач при написаниеи CSS-кода.
        </li>
        <li>
            Структура проекта - препроцессор позволяет писать стили в отдельных файлах, что повышает качество структуры проекта и поиск стилей отдельных блоков.
        </li>
        <li>
            Чистота кода - из-за того что стили пишутся в отдельных файлах и применяются вспомогательные конструкции для повторного использования кода, он становится чище.
        </li>
    </ul>
    НЕДОСТАТКИ
    <ul>
        <li>
            Синтаксис - дополнительные конструкции препроцессора это новый синтаксис, который необходимо выучить и привыкнуть использовать.
        </li>
        <li>
            Компиляция - шаг подготовки кода препроцессора для браузера, то есть преобразование всех синтаксических конструкций в обычный CSS.
        </li>
    </ul>

    <h2>Синтаксис</h2>
    <p>
        Сегодня используется синтаксис SCSS (Sassy CSS), который является расширением оригинального CSS-синтаксиса . Это значит, что любое допустимое значение в CSS-стилях будет допустимо и в SCSS. Файлы с этим синтаксисом имеют расширение .scss, например main.scss.
    </p>
    <img src="./images/sass.JPG" alt="">
    <h2>Компиляция</h2>
    <img src="./images/sass-compilation.jpg" alt="">
    <p>
        Браузер не понимает синтаксиса специальных конструкций SASS, поэтому код препроцессора необходимо преобразовать (скомпилировать) в CSS. Способов компиляции довольно много: различные консольные утилиты, сборщики и плагины редактора.
    </p>
    Процесс разработки сводится к следующим шагам:
    <ul>
        <li>
            Настраиваем инструмент для компиляции SASS-кода
        </li>
        <li>
            Пишем SASS-код в sass-файлах
        </li>
        <li>
            SASS автоматически компилируется в CSS и создаётся CSS-файл
        </li>
        <li>
            Подключаем скомпилированный CSS-файл в index.html
        </li>
    </ul>
    <div class="advice">
        <b>ПОЛЕЗНО</b>
        <ul>
            <li>
                Для тренировки синтаксиса можно использовать интерактивную площадку <a href="https://www.sassmeister.com/">SassMeister</a>.
            </li>
            <li>
                Можно воспользоваться удобным приложением <a href="https://scout-app.io/">Scout-App</a>.
            </li>
            <li>
                В редакторе VSCode есть расширение Live Sass Compiler, для компиляции SASS.
            </li>
        </ul>
    </div>

    <h1>Препроцессор SASS</h1>
    <p>
        Рассмотрим самые полезные синтаксические возможности SASS, освоить которые для дальнейшего применения можно за несколько часов.
    </p>
    <h2>Переменные</h2>
    <p>
        Переменные и операции над ними это одна из самых простых, и в то же время мощных особенностей препроцессоров. Синтаксис объявления переменной - знак $ перед именем и её значение после двоеточия.
    </p>
    <img src="./images/variable.JPG" alt="">
    <p>Будет скомпилирован в следующий CSS.</p>
    <img src="./images/variable1.JPG" alt="">
    <p>
        Имена переменных должны быть описательные, чтобы из имени было понятно что там хранится. Переменная $color-blue имеет немного смысла (кроме того, что она указывает на синий цвет), а вот $color-accent, $color-primary или $color-background показывает роль этого цвета. Семантические, описательные имена переменных не требуют переименования, например при изменении палитры брендовых цветов компании.
    </p>
    <div class="advice">
        <b>ПОЛЕЗНО</b>
        <p>
            Имена переменных могут быть записаны в kebab-case, snake_case или camelCase нотациях. Главное, чтобы в проекте использовался только один из этих стилей, для однородности кода.
        </p>
    </div>

    <h2>Область видимости</h2>
    <p>
        Переменные доступны только в пределах того уровня вложенности селекторов, на котором они определены. То есть, если переменная объявлена в селекторе, она доступна только в нём. Переменная объявляемая вне каких-либо селекторов, доступна глобально.
    </p>
    <img src="./images/visibile-area.JPG" alt="">
    <p>
        В случае когда в имени переменной сделана ошибка или такой переменной нет в доступной области видимости, будет ошибка компиляции стилей.
    </p>

    <h1>Вложенность селекторов</h1>
    <p>
        Подобно вложености тэгов в HTML, в SASS можно вкладывать одно правило в другое. Это одна из наиболее полезных, а также неправильно используемых возможностей.
    </p>
    <p>
        Вложенность позволяет иметь одни объявления правил внутри других. В обычном CSS мы могли бы написать следующий код для стилизации секции и её заголовка и абзаца.
    </p>
    <img src="./images/nesting.JPG" alt="">
    <p>
        В SASS можем получить тот же результат, написав следующий код.
    </p>
    <img src="./images/nesting1.JPG" alt="">
    <h2>Конкатенация селекторов</h2>
    <p>
        В SASS можем получить тот же результат, написав следующий код.
    </p>
    <p>
        Запишем имена классов из предыдущего примера по принципу родитель-потомок.
    </p>
    <img src="./images/nesting2.JPG" alt="">
    <p>
        Тогда используя оператор конкатенации в SASS можем получить тот же результат.
    </p>
    <img src="./images/nesting3.JPG" alt="">
    <p>
        Тогда используя оператор конкатенации в SASS можем получить тот же результат.
    </p>
    <img src="./images/nesting4.JPG" alt="">
    <p>
        Используя вложенность селекторов и оператор конкатенации можем записть аналог в SASS.
    </p>
    <img src="./images/nesting5.JPG" alt="">
    <p>
        А что делать если :hover и :focus в CSS сгруппированы?
    </p>
    <img src="./images/nesting6.JPG" alt="">
    <p>
        Ничего не меняется, без проблем группируем и в SASS, не забывая поставить & там, где необходимо пришить родительский селектор.
    </p>
    <img src="./images/nesting7.JPG" alt="">

    <h2>Правила вложенности</h2>
    <p>
        Вложенность селекторов это отличный способ сэкономить время и упростить поддержку, но чрезмерная вложенность гарантированно вызовет проблемы с читабельностью кода.
    </p>
    <p>
        Представим следующую разметку кнопки с иконкой и текстом.
    </p>
    <img src="./images/nesting8.JPG" alt="">
    <p>
        Запишем какие-то стили и сделаем их специально чуть-чуть сложнее чем нужно.
    </p>
    <img src="./images/nesting9.JPG" alt="">
    <p>
        Теперь запишем аналог в SASS используя вложенность и конкатенацию.
    </p>
    <img src="./images/nesting10.JPG" alt="">
    <p>
        Прочитать такую запись быстро довольно сложно, визуально теряется связь с родитеским селектором и вместо того чтобы разбирать CSS-код, приходится вчитываться в синтаксис вложенностей. То есть используя возможности препроцессора мы сделали хуже - больше не всегда лучше.
    </p>
    <p>
        Создавайте новое правило для каждого элемента, а вложенности и конкатенации используйте для оформления состояний.
    </p>
    <img src="./images/nesting11.JPG" alt="">

    <h1>Математические операции</h1>
    <p>
        До того как в CSS появилась функция calc(), препроцессоры были единственным решением если было необходимо выполнить математические вычисления. Операции над числами поддерживают стандартные операции: +, -, *, / и % (остаток от деления по модулю).
    </p>
    <img src="./images/math.JPG" alt="">

    <h2>Ограничение</h2>
    <p>
        В отличии от фуцнкции calc(), в препроцессоре нельзя смешивать типы единиц. При попытке скомпилировать код из следующего примера - будет ошибка.
    </p>
    <img src="./images/math1.JPG" alt="">
    <p>
        Дело в том, что препроцессор не знает сколько будет 100% или 5rem в пикселях заранее. Значения относительных единиц в пикселях можно узнать только в момент рендера HTML-страницы. Поэтому для таких вычислений необходимо использовать нативную функцию calc().
    </p>
    <img src="./images/math2.JPG" alt="">

    <h1>Расширения стилей с @extend</h1>
    <p>
        Директива @extend используется для наследования уже существующих стилей. Используем её чтобы создать компонент кнопки с несколькими состояниями.
    </p>
    <img src="./images/extend.JPG" alt="">
    <p>
        Расширение (наследование) не сделает копию стилей для каждого селектора, а грамотно добавит нужные селекторы в перечисление к правилу с наследуемыми стилями. Вот как это будет выглядеть после компиляции.
    </p>
    <img src="./images/extend1.JPG" alt="">
    
    <h2>Плейсхолдеры</h2>
    <p>
        Но что, если мы хотим расширить набор стилей, базовый селектор для которого не нужен? Например если не нужен селектор .button из предыдущего примера, ведь сам по себе он ничего не делает и в HTML использован не будет.
    </p>
    <p>
        Для таких случаев существует placeholder (плейсхолдер, местозаполнитель, шаблон) - произвольное имя селектора с обязательным символом % в начале, например %button.
    </p>
    <img src="./images/placeholder.JPG" alt="">
    <p>
        После компиляции будут доступны селекторы .button-success и .button-error привязанные к правилу шаблона, а самого имени шаблона в CSS не будет.
    </p>
    <img src="./images/placeholder1.JPG" alt="">

    <h2>Миксины</h2>
    <p>
        Директива @mixin, как и плейсхолдеры, позволяет создавать готовые наборы свойств, но с различными значениями, в зависимости от полученных аргументов при вызове миксина.
    </p>
    <img src="./images/mixin.JPG" alt="">
    <p>
        Миксин объявляется с помощью директивы @mixin и его имени. Далее могут идти необязательные параметры в круглых скобках (сами скобки обязательны), а в фигурных - набор свойств и значений.
    </p>
    <p>
        Создадим миксин для задания только верхней и нижней рамки элемента, и сделаем цвет рамки настраиваемым значением.
    </p>
    <img src="./images/mixin1.JPG" alt="">
    <p>
        Добавить стили миксина к селектору можно при помощи директивы @include, после которой вызываем миксин и передаём значения для настраиваемых свойств.
    </p>
    <img src="./images/mixin2.JPG" alt="">
    <p>
        После компиляции будут только правила для селекторов .section и .header с добавленным кодом из миксина, кода объявления самого миксина не будет.
    </p>
    <img src="./images/mixin3.JPG" alt="">
    <div class="attention">
        <b>ВНИМАНИЕ</b>
        <p>
            Миксин отличается от плейсхолдера тем, что свойства дублируются в каждый селектор. Всё потому, что значения свойств миксина могут быть разные, в зависимости от переданных аргументов при вызове @include миксин(аргументы). В то время как свойства и их значения в плейсхолдере всегда одинаковые.
        </p>
    </div>

    <h1>Карты (словари)</h1>
    <p>
        Объявим несколько переменных для хранения палитры цветов проекта. Они слабо связаны, по сути это просто набор переменных с префиксом color для указания того, что они хранят цвет.
    </p>
    <img src="./images/get-map.JPG" alt="">
    <p>
        Карта (словарь) позволяет хранить набор связанной информации в формате термин: определение. Например, вместо нескольких несвязанных переменных хранящих палитру проекта, можно записать карту (словарь) цветов. Карта состоит из имени переменной, в которой она хранится, и набора свойств в формате ключ: значение разделенных запятыми, внутри пары круглых скобок.
    </p>
    <img src="./images/get-map1.JPG" alt="">
    <p>
        Имя цвета может быть произвольное, это просто название свойства. Такая карта позволит упорядоченно и многократно получать доступ к цветам. Для того чтобы получить значение свойства используется встроенная SASS-функция map-get().
    </p>
    <img src="./images/get-map2.JPG" alt="">
    <p>
        Первым аргументом передаём имя переменной в которой находится словарь, вторым имя свойства значение которого необходимо получить. Имя свойства должно быть строкой, то есть обёрнуто в одинарные или двойные кавычки.
    </p>
    <img src="./images/get-map3.JPG" alt="">
    <p>
        Постоянно писать map-get() и передавать имя карты неудобно. Напишем свою функцию-утилиту для более простого доступа к свойствам карты цветов. Эту функцию объявляем в том-же файле где и карта.
    </p>
    <img src="./images/get-map4.JPG" alt="">
    <p>
        После импорта файла _colors.scss можно использовать функцию getColor(имя_свойства).
    </p>
    <img src="./images/get-map5.JPG" alt="">


    <h1>Дополнительные материалы</h1>
    <ul>
        <li>
            <a href="https://sass-scss.ru/documentation/">Документация SASS (рус)</a>
        </li>
        <li>
            <a href="https://sass-lang.com/">Документация SASS (англ)</a>
        </li>
        <li>
            <a href="https://tproger.ru/translations/complete-sass-guide/">Развёрнутое руководство по SASS</a>
        </li>
        <li>
            <a href="http://prgssr.ru/development/estetichnyj-sass-chast-1-arhitektura-i-organizaciya.html">Эстетичный Sass часть 1: архитектура и организация</a>
        </li>
        <li>
            <a href="http://www.thesassway.com/beginner">Сборник туториалов по SASS</a>
        </li>
    </ul>

    <h1>Вендорные префиксы</h1>
    <p>
        Вендорные префиксы - это специальные приставки, используемые производителями (вендорами) браузеров для экспериментальных, еще не принятых в стандарт, или не полностью реализованных в браузере CSS-свойств и значений.
    </p>
    <p>Список вендорных префиксов по браузерам:</p>
    <ul>
        <li>
            -webkit- - Chrome, Safari, Edge, новые версии Opera
        </li>
        <li>
            -moz- - Firefox
        </li>
        <li>
            -o- - Старые версии Opera
        </li>
        <li>
            -ms- - Internet Explorer
        </li>
    </ul>

    <div class="attention">
        <b>ВНИМАНИЕ</b>
        <p>
            Вручную прописывать их не нужно, для этого используются специальные инструменты которые автоматизируют процесс, например SASS-комилятор с дополнительными настройками. Для ознакомления можно использовать интерактивную площадку <a href="https://autoprefixer.github.io/">https://autoprefixer.github.io/</a>.   
        </p>
    </div>
    <p>
        Например, следующий CSS-код будет работать в большинстве последних версий современных браузеров.
    </p>
    <img src="./images/prefix.JPG" alt="">
    <p>
        После обработки автопрефиксером получаем следующий код, который будет гарантированно работать в последних 4-х версиях всех современных браузеров. Нужное количество версий выбирается в интерфейсе автопрефиксера.
    </p>
    <img src="./images/prefix1.JPG" alt="">
    <p>
        Браузеры которые поддерживают нативные свойства и значения проигнорируют их аналоги с верндорными префиксами, и наоборот.
    </p>

    <section class="webinar">
        <h1>
            Материалы с вебинара с Репетой
        </h1>
        

    </section>






</body>